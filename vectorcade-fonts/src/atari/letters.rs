//! Letter glyphs A-Z for ATARI style.
//! Data-driven: static arrays converted to GlyphPathCmds.

use glam::Vec2;
use vectorcade_shared::font::{GlyphPath, GlyphPathCmd};

type GlyphData = &'static [(bool, f32, f32)];

pub fn glyph(ch: char) -> Option<Vec<GlyphPath>> {
    let idx = (ch as u8).checked_sub(b'A')? as usize;
    if idx >= 26 { return None; }
    Some(vec![build_path(GLYPHS[idx], CLOSES[idx])])
}

fn build_path(data: GlyphData, close: bool) -> GlyphPath {
    let mut cmds: Vec<GlyphPathCmd> = data.iter().map(|&(is_mv, x, y)| {
        let p = Vec2::new(x, y);
        if is_mv { GlyphPathCmd::MoveTo(p) } else { GlyphPathCmd::LineTo(p) }
    }).collect();
    if close { cmds.push(GlyphPathCmd::Close); }
    GlyphPath { cmds }
}

// M=MoveTo(true), L=LineTo(false)
const M: bool = true;
const L: bool = false;

static GLYPHS: [GlyphData; 26] = [
    // A: box with crossbar
    &[(M,0.2,0.1),(L,0.2,0.9),(L,0.8,0.9),(L,0.8,0.1),(M,0.2,0.5),(L,0.8,0.5)],
    // B: bumpy right side
    &[(M,0.2,0.1),(L,0.2,0.9),(L,0.7,0.9),(L,0.8,0.8),(L,0.8,0.6),(L,0.7,0.5),
      (L,0.2,0.5),(L,0.7,0.5),(L,0.8,0.4),(L,0.8,0.2),(L,0.7,0.1),(L,0.2,0.1)],
    // C
    &[(M,0.8,0.9),(L,0.2,0.9),(L,0.2,0.1),(L,0.8,0.1)],
    // D
    &[(M,0.2,0.1),(L,0.2,0.9),(L,0.6,0.9),(L,0.8,0.7),(L,0.8,0.3),(L,0.6,0.1),(L,0.2,0.1)],
    // E
    &[(M,0.8,0.9),(L,0.2,0.9),(L,0.2,0.1),(L,0.8,0.1),(M,0.2,0.5),(L,0.6,0.5)],
    // F
    &[(M,0.8,0.9),(L,0.2,0.9),(L,0.2,0.1),(M,0.2,0.5),(L,0.6,0.5)],
    // G
    &[(M,0.8,0.9),(L,0.2,0.9),(L,0.2,0.1),(L,0.8,0.1),(L,0.8,0.5),(L,0.5,0.5)],
    // H
    &[(M,0.2,0.9),(L,0.2,0.1),(M,0.8,0.9),(L,0.8,0.1),(M,0.2,0.5),(L,0.8,0.5)],
    // I
    &[(M,0.3,0.9),(L,0.7,0.9),(M,0.5,0.9),(L,0.5,0.1),(M,0.3,0.1),(L,0.7,0.1)],
    // J
    &[(M,0.3,0.9),(L,0.7,0.9),(M,0.5,0.9),(L,0.5,0.2),(L,0.3,0.1),(L,0.2,0.2)],
    // K
    &[(M,0.2,0.9),(L,0.2,0.1),(M,0.8,0.9),(L,0.2,0.5),(L,0.8,0.1)],
    // L
    &[(M,0.2,0.9),(L,0.2,0.1),(L,0.8,0.1)],
    // M
    &[(M,0.2,0.1),(L,0.2,0.9),(L,0.5,0.6),(L,0.8,0.9),(L,0.8,0.1)],
    // N
    &[(M,0.2,0.1),(L,0.2,0.9),(L,0.8,0.1),(L,0.8,0.9)],
    // O
    &[(M,0.2,0.1),(L,0.8,0.1),(L,0.8,0.9),(L,0.2,0.9),(L,0.2,0.1)],
    // P
    &[(M,0.2,0.1),(L,0.2,0.9),(L,0.8,0.9),(L,0.8,0.5),(L,0.2,0.5)],
    // Q
    &[(M,0.2,0.1),(L,0.8,0.1),(L,0.8,0.9),(L,0.2,0.9),(L,0.2,0.1),(M,0.6,0.3),(L,0.9,0.0)],
    // R
    &[(M,0.2,0.1),(L,0.2,0.9),(L,0.8,0.9),(L,0.8,0.5),(L,0.2,0.5),(L,0.8,0.1)],
    // S
    &[(M,0.8,0.9),(L,0.2,0.9),(L,0.2,0.5),(L,0.8,0.5),(L,0.8,0.1),(L,0.2,0.1)],
    // T
    &[(M,0.2,0.9),(L,0.8,0.9),(M,0.5,0.9),(L,0.5,0.1)],
    // U
    &[(M,0.2,0.9),(L,0.2,0.1),(L,0.8,0.1),(L,0.8,0.9)],
    // V
    &[(M,0.2,0.9),(L,0.5,0.1),(L,0.8,0.9)],
    // W
    &[(M,0.1,0.9),(L,0.3,0.1),(L,0.5,0.5),(L,0.7,0.1),(L,0.9,0.9)],
    // X
    &[(M,0.2,0.9),(L,0.8,0.1),(M,0.8,0.9),(L,0.2,0.1)],
    // Y
    &[(M,0.2,0.9),(L,0.5,0.5),(L,0.8,0.9),(M,0.5,0.5),(L,0.5,0.1)],
    // Z
    &[(M,0.2,0.9),(L,0.8,0.9),(L,0.2,0.1),(L,0.8,0.1)],
];

static CLOSES: [bool; 26] = [false; 26];
